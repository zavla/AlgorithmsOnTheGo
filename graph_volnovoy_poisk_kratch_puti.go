//Волновой алгоритм находит длинну кратчайшего пути но в невзвешенном графе.
package main

//если граф не взвешенный то все пути из вершины равнозначны например стоимость 1.
//если граф взвешенный и есть веса на дугах то надо использовать алгоритм Дейкстры.

func graph_volnovoy_poisk_shortest_path(adj [][]int, start int) []int {
	//использовать массив D длинн путей пока что кратчайших размером V
	//старт с начальной вершины, v.
	//получаем список смежных вершин near с данной - что тожк самое проходим по строке v
	//у каждого из списка проставили путь на 1 больше чем к данной если там было большее число.
	//добавили в список смежн вершин вершины для обработки
	D := make([]int, len(adj)) //массив кратч путей до вершин покачто

	vToDo := make([]int, 1, len(adj)) //список вершин для обхода
	//изначально там только start
	vToDo[0] = start
	vVisited := make(map[int]bool, len(adj))
	for j := 0; j < len(vToDo); j++ {
		v := vToDo[j]
		//проходимся по v строке
		vVisited[v] = true
		for i := 0; i < len(adj); i++ {
			if adj[v][i] == 0 {
				continue
			}
			if _, ok := vVisited[i]; ok {
				continue
			}
			//каждую вершину которую мы проходим мы добавляем в список lToDo
			//но только если она еще не в списке посещенных
			vToDo = append(vToDo, i)
			//далее заполняем массив кратч путей
			if D[i] > D[v]+1 || D[i] == 0 {
				D[i] = D[v] + 1
			}
		}

	}
	return D
}
