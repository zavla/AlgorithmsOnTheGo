//LCS - largest common sequence
//НОП - наиб общая последовательность
//начать с вычисления общ последовательности с меньших размеров
//с размеров a=1 и b=1
//для каждой комбинации i,j вычислять размер общей последовательности.
package main

func max[T ~int](a, b T) T { //~ underlying type
	if a < b {
		return b
	}
	return a

}

func LCS(a, b []int) (int, []int) {
	//023456
	//2430506
	// L[i][j] - будут длины НОП кусочков наших исходных последовательностей длиннами i и j
	//одна заканчивается на a[i] вторая заканчивается на b[j]
	//тут возможны два варианта: последние элементы равны и мы можем про них временно забыть,
	//		считаем что они входять НОП этого кусочка и решаем задачу для L[i-1][j-1] т.е. кусочки
	//		на 1 меньшие. Когда мы ее решим мы добавим 1 к тому что получтся как знак того что
	//		пследний эл-т тоже будет входить в общ послед.
	//или они не равны, что значит что один из них точно не входит в НОП. Поэтому выбираем НОП из
	//	L[i-1][j], L[i][j-1] - ответ к ним будет ответом к нашей задачи.
	L := make([][]int, len(a)+1)
	for i := range L {
		L[i] = make([]int, len(b)+1) //создание массива массивов
	}
	for i := 1; i <= len(a); i++ {
		for j := 1; j <= len(b); j++ {

			if a[i-1] == b[j-1] { //индексы в массивы с 0
				L[i][j] = L[i-1][j-1] + 1
			} else {
				L[i][j] = max(L[i-1][j], L[i][j-1])
			}
		}
	}
	//пр-оход от последнего элемента чтобынайти самупоследовательность
	i := len(a) - 1
	j := len(b) - 1
	thelcs := make([]int, 0, L[len(a)][len(b)])
	for {
		if a[i] == b[j] {
			thelcs = append(thelcs, a[i])
			i--
			j--
		} else {
			if L[i+1][j+1-1] > L[i+1-1][j+1] { //здесь +1 отражает факт что L на 1 больше по размеру чем a,b
				j--
			} else {
				i--
			}
		}

		if i < 0 || j < 0 {
			break
		}
	}
	//полученый thelcs в обратном порядке
	for i := 0; i <= len(thelcs)/2; i++ {
		thelcs[i], thelcs[len(thelcs)-1-i] = thelcs[len(thelcs)-1-i], thelcs[i]

	}
	return L[len(a)][len(b)], thelcs
}
