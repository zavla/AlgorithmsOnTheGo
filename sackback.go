//Задача о рюкзаке.
package main

//какую максимальную стоимость можно вместить в рюкзак массой М если есть предметы массими m[i],i<=n, и стоимостью c[i] каждый.
//№грузика
//стоимость 	c 1 2 3 5
//масса 		m 1 4 6 3
// ---------
//на входе массив весов предметов m и массив с стоимости предметов.
//W - размер рюкзака в кг.
func sackback(W int, m, c []int) (int, []int) {
	//решим задачу сначала для одного грузика со всеми остатками свободного места. остатки свободного места в кг.
	//заполняем таблицу выгод от размещения первого грузика(грузиков) в остатках свободного места.
	//как выгоднее заполнить 1 кг свободного места если есть только один грузик. два грузика.
	//На десятом грузике мы уже в таблице видим что если мы его берем то заполненность рюкзака с остатком места под десятый
	// грузик чтобы его взять оптимальная такая-то.
	// Добавим десятый предмет - получим выгоду такую-то. Проверим что она не меньше
	// если десятый предмет не брать.
	// 			номера грузиков\предметов
	// 	табА		1	2	3	4	5	...
	// 		0кг
	// с  	1кг
	// в	2кг
	// о	3кг
	// б	4кг
	// о	5кг
	// д	.
	// н	.
	// о	.
	// е
	// место
	N := len(m) //для краткости записи это число предметов

	//создаем А=таблица выгод, в строках килограммы, в столбцах номера\индексы грузиков
	A := make([][]int, W+1) //таблица выгод. есть W строк 1кг, 2кг, 3кг, индекс будет сравниваться с кг.
	for i := 0; i < len(A); i++ {
		A[i] = make([]int, N) //создаем А, в строках килограммы, в столбцах номера\индексы грузиков
	}
	ret := 0

	//т.к. индекс kg сравнивается с реальным весом в кг то надо его начать с 1, а не 0.
	for kg := 1; kg <= W; kg++ { //для каждого кг, т.е. для каждого свободного места в мешке
		for j := 0; j < N; j++ { //для каждого грузика, j это номер грузика
			profit1 := 0
			profit2 := 0
			if j > 0 {
				//возможна прибыль без этого товара, т.е. другими товарами заполнили эти килограммы
				profit1 = A[kg][j-1]
			}
			if kg >= m[j] { //если рассматриваем остаток в мешке больший чем вес грузика
				//возможно прибыль с этим товаром но оптимально заполненны килограммы без него
				profit2 = A[kg-m[j]][j] + c[j]
			}
			//из двух вариантов прибылей выбрать большую
			A[kg][j] = max(profit1, profit2) //либо без этого товара такое же число кг, либо с этим товаром но оптимально забитые предыдущие килограммы
		}
	}
	ret = A[W][N-1] //строки нумеруються до W включительно, а колонки до N-1

	//знаем макс выгоду, найдем обратным ходом то из каких грузиков она получилась
	items := []int{}
	kg := W
	j := N - 1
	for {
		profit := A[kg][j]
		if j == 0 {
			break
		}
		if profit == A[kg][j-1] { //значит грузки j не брался
			j--
			continue
		}

		items = append(items, j)
		kg = kg - m[j]

	}
	return ret, items
}
